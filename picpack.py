import argparse, PyInstaller.__main__, random, zipfile, platform, shutil, os, logging
from picpack_internals import gen
parser = argparse.ArgumentParser(prog="picpack", description="Turns a Picturesque file into an executable.")
parser.add_argument("filename", help="the filename to be packaged")
parser.add_argument("-w", "--windowed", action="store_true", help="specifies if the resulting executable is windowed or not (ignored on Linux)")
parser.add_argument('-f', '--additional-filenames', nargs='+', help='gives additional filenames to be included in the program')
parser.add_argument('-z', '--additional-filenames-zip', nargs='+', help='EXPERIMENTAL: normally, when you create an executable using picpack -f or picpack --additional-filenames, it copies the contents of the files and recreates them on runtime. this works well, but doesn\'t help the speed much. this option has the same syntax as --additional-filenames, but instead of copying all the files one by one, it creates a zip file, and extracts it at runtime.')
args = parser.parse_args()
def getcode():
   chars = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890_"
   code = ""
   for x in range(10):
      code += chars[random.randint(0, len(chars)-1)]
   return "picpack-"+code
code = getcode()
log = logging.getLogger("PyInstaller.__main__")
log.info("Creating the file to use PyInstaller on...")
f = open(f"{args.filename}.{code}.py", "w")
gen.genfile(args, log, f, code)
f.close()
log.info("Copying the zipped Picturesque interpreter...")
f = open(f"{code}.zip", "wb")
if True: # zipped interpreter file
   f.write(b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x8c\x92\x1aY\xf1\xcfVNR\x03\x00\x00R\x03\x00\x00\x0e\x00\x00\x00ipic/errors.pyclass PicturesqueException(Exception):\r\n   def __init__(self, msg=""):\r\n      self.value = msg\r\n   def __str__(self):\r\n      return self.value\r\nclass PicturesqueUnreconizedCommandException(PicturesqueException): pass\r\nclass PicturesqueUnreconizedEventException(PicturesqueException): pass\r\nclass PicturesqueCommandNotInNamespaceException(PicturesqueException): pass\r\nclass PicturesqueWindowNotFoundException(PicturesqueException): pass\r\nclass PicturesqueInvalidWidgetException(PicturesqueException): pass\r\nclass PicturesqueInvalidOSException(PicturesqueException): pass\r\nclass PicturesqueInvalidURLException(PicturesqueException): pass\r\nclass PicturesqueTooManyArgumentsException(PicturesqueException): pass\r\nclass PicturesqueTooLittleArgumentsException(PicturesqueException): pass\r\nclass PicturesqueNotANamespaceException(PicturesqueException): passPK\x03\x04\x14\x00\x00\x00\x00\x00\xba\x93\x1aY\x00\xa2\xbd\x98\xb3\x9f\x00\x00\xb3\x9f\x00\x00\x0c\x00\x00\x00ipic/lang.pyimport turtle as iturtle, time, string, matplotlib.pyplot, numpy, plotly.express, sys, ipic.errors, ipic.out, tkinter, json, tkinter.ttk, tkinter.messagebox, tkinter.colorchooser, tkinter.scrolledtext, shlex, tkinter.filedialog, os, ipic.type, webbrowser, pstats, io, __main__, ipic.path, sysconfig, platform, ftplib, configparser, textwrap, csv, ipic.table, plistlib, dbm, sqlite3, atexit, wsgiref.simple_server, tomllib, netrc, urllib.request, colorsys, getpass, ipic.string, hashlib, ipic.ns, importlib, warnings, ipic.warnings, ipic.ns\r\n__author__ = "Ridwan bin Mohammad (Tiash)"\r\n__credits__ = """Thank you to my dad, who was only too pleased to take a look at Picturesque when I first made it (my mom was too \r\nangry about her keyboard falling on the floor, and wouldn\'t take a look), and my mom and dad, for \r\nencouraging me. Thanks to the people who made \'Help Your Kids With Computer Coding\', for giving me the idea.\r\n"""\r\ntry: \r\n   import cProfile as profile\r\nexcept ImportError:\r\n   import profile\r\nif platform.system() == \'Windows\':\r\n   import winsound\r\nstamps = []\r\nout = ipic.out.PicturesqueOutputHandler()\r\nturtle_gone = False\r\niturtle.title("Picturesque")\r\ntkinter_win_ids = {}\r\nsinglevar_list = [None, None, None, None, {}]\r\nvar_dict = {}\r\nproc_dict = {}\r\nns_list = {}\r\nTODO_CALL = lambda x: x()\r\nPROC_TYPE_PIC = "pic"\r\nPROC_TYPE_PY = "py"\r\nPROC_IDX_ARGS = 0\r\nPROC_IDX_CODE = 1\r\nPROC_IDX_TYPE = 2\r\nSVLIST_IDX_FTP = 0\r\nSVLIST_IDX_UNIXDB = 1\r\nSVLIST_IDX_SQLDB = 2\r\nSVLIST_IDX_SQLCUR = 3\r\nSVLIST_IDX_NSDATA = 4\r\nns_sys_var = {}\r\nclass_dict = {}\r\ndef sub(code):\r\n   return code.replace(",", ";").replace("\'", ",").replace("`", "\'")\r\ndef interpret(do, val, lineno, line, is_console, filename, is_artist, proc):\r\n   global turtle_gone\r\n   if do == "FORWARD":\r\n      iturtle.forward(int(val))\r\n   elif do == "BACKWARD":\r\n      iturtle.backward(int(val))\r\n   elif do == "RIGHT":\r\n      iturtle.right(int(val))\r\n   elif do == "LEFT":\r\n      iturtle.left(int(val))\r\n   elif do == "PATH.END" or do == "PEN.UP":\r\n      iturtle.penup()\r\n   elif do == "PATH.BEGIN" or do == "PATH.START" or do == "PEN.DOWN":\r\n      iturtle.pendown()\r\n   elif do == "RESET":\r\n      iturtle.reset()\r\n   elif do == "CLEAR":\r\n      iturtle.clearscreen()\r\n   elif do == "COLOR":\r\n      iturtle.color(val)\r\n   elif do == "FILL":\r\n      iturtle.fillcolor(val)\r\n   elif do == "HOME":\r\n      iturtle.home()\r\n   elif do == "FILLCOLOR.START" or do == "FILLCOLOR.BEGIN":\r\n      iturtle.begin_fill()\r\n   elif do == "FILLCOLOR.END":\r\n      iturtle.end_fill()\r\n   elif do == "WAIT":\r\n      time.sleep(float(val))\r\n   elif do == "SETX":\r\n      iturtle.setx(int(val))\r\n   elif do == "SETY":\r\n      iturtle.sety(int(val))\r\n   elif do == "STAMP":\r\n      stamps.append(iturtle.stamp())\r\n   elif do == "STAMPS.CLEAR":\r\n      iturtle.clearstamps()\r\n   elif do == "SPEED":\r\n      iturtle.speed(int(val))\r\n   elif do == "SIZE":\r\n      iturtle.pensize(int(val))\r\n   elif do == "LOGLN":\r\n      out.output(val)\r\n   elif do == "CIRCLE":\r\n      iturtle.circle(int(val))\r\n   elif do == "OUTLINE":\r\n      iturtle.pencolor(val)\r\n   elif do == "HIDE":\r\n      iturtle.hideturtle()\r\n   elif do == "SHOW":\r\n      iturtle.showturtle()\r\n   elif do == "SCREEN.COLOR":\r\n      iturtle.getscreen().bgcolor(val)\r\n   elif do == "SCREEN.IMAGE":\r\n      iturtle.getscreen().bgpic(val)\r\n   elif do == "CLOSEONCLICK":\r\n      iturtle.getscreen().exitonclick()\r\n      turtle_gone = True\r\n   elif do == "MODE":\r\n      iturtle.mode(val)\r\n   elif do == "SETWORLDCOORDINATES":\r\n      iturtle.getscreen().setworldcoordinates(tuple(map(int, val.split(\' \'))))\r\n   elif do == "CLOSETURTLE":\r\n      iturtle.bye()\r\n      turtle_gone = True\r\n   elif do == "DOT":\r\n      args = val.split(\' \')\r\n      iturtle.dot(args[0], args[1])\r\n   elif do == "GOTO":\r\n      iturtle.setpos(tuple(map(int, val.split(\' \'))))\r\n   elif do == "SHAPE":\r\n      iturtle.shape(val.lower())\r\n   elif do == "HELP":\r\n      webbrowser.open("https://picturesque-documentation.readthedocs.io/")\r\n   elif do == "EXIT":\r\n      if val != "":\r\n         sys.exit(int(val))\r\n      else:\r\n         sys.exit(0)\r\n   elif do == "INCLUDE":\r\n      lexer(open(ipic.path.path_insensitive(val), "r").read())\r\n   elif do == "VAR":\r\n      args = [val[:val.find(" ")], val[val.find(" ")+1:]]\r\n      var_dict[args[0]] = args[1]\r\n   elif do == "PLOT":\r\n      matplotlib.pyplot.figure(num = "Picturesque")\r\n      cival = line[line.find(" ")+1:]\r\n      xpoints = numpy.array([int(x) for x in list(val[:val.find(" * ")].split(" "))])\r\n      if val.find(" : ") >= -1:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):val.find(" : ")].split(" "))])\r\n         matplotlib.pyplot.plot(xpoints, ypoints, cival[cival.find(" : ")+len(" : "):].lower())\r\n      else:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):].split(" "))])\r\n         matplotlib.pyplot.plot(xpoints, ypoints)\r\n      matplotlib.pyplot.show()\r\n   elif do == "BAR":\r\n      matplotlib.pyplot.figure(num = "Picturesque")\r\n      xpoints = numpy.array([x.replace("\\\\S", " ").replace("\\\\(S)", "\\\\S") for x in list(val[:val.find(" * ")].split(" "))])\r\n      if val.find(" : ") >= -1:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):val.find(" : ")].split(" "))])\r\n         matplotlib.pyplot.bar(xpoints, ypoints, color = val[val.find(" : ")+len(" : "):].lower())\r\n      else:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):].split(" "))])\r\n         matplotlib.pyplot.bar(xpoints, ypoints)\r\n      matplotlib.pyplot.show()\r\n   elif do == "BARH":\r\n      matplotlib.pyplot.figure(num = "Picturesque")\r\n      xpoints = numpy.array([x.replace("\\\\S", " ").replace("\\\\(S)", "\\\\S") for x in list(val[:val.find(" * ")].split(" "))])\r\n      if val.find(" : ") >= -1:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):val.find(" : ")].split(" "))])\r\n         matplotlib.pyplot.barh(xpoints, ypoints, color = val[val.find(" : ")+len(" : "):].lower())\r\n      else:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):].split(" "))])\r\n         matplotlib.pyplot.barh(xpoints, ypoints)\r\n      matplotlib.pyplot.show()\r\n   elif do == "PIE":\r\n      matplotlib.pyplot.figure(num = "Picturesque")\r\n      mylabels = shlex.split(val[:val.find(" * ")])\r\n      if val.find(" : ") >= -1:\r\n         y = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):val.find(" : ")].split(" "))])\r\n         matplotlib.pyplot.pie(y, labels = mylabels, colors = list(val[val.find(" : ")+len(" : "):].lower().split(" ")))\r\n      else:\r\n         y = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):].split(" "))])\r\n         matplotlib.pyplot.pie(y, labels = mylabels)\r\n      matplotlib.pyplot.legend(title = "Legend")\r\n      matplotlib.pyplot.show()\r\n   elif do == "HIST":\r\n      matplotlib.pyplot.figure(num = "Picturesque")\r\n      if not val.startswith("RANDOM"):\r\n         x = numpy.array([float(i) for i in list(val.split(" "))]);\r\n         matplotlib.pyplot.hist(x)\r\n      else:\r\n         args = val.split(" ")[1:]\r\n         if len(args) > 1:\r\n            x = numpy.random.normal(int(args[0]), int(args[1]), int(args[2]))\r\n            matplotlib.pyplot.hist(x)\r\n         else:\r\n            x = numpy.random.normal(170, 10, 250)\r\n            matplotlib.pyplot.hist(x)\r\n      matplotlib.pyplot.show()\r\n   elif do == "BBAR":\r\n      xpoints = shlex.split(val[:val.find(" * ")])\r\n      if val.find(" | ") > -1:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):val.find(" | ")].split(" "))])\r\n         plotly.express.bar(x=xpoints, y=ypoints).write_html(val[val.find(" | ")+len(" | "):])\r\n      else:\r\n         ypoints = numpy.array([int(x) for x in list(val[val.find(" * ")+len(" * "):].split(" "))])\r\n         plotly.express.bar(x=xpoints, y=ypoints).show()\r\n   elif do == "EVAL":\r\n      lexer(sub(val), filename="<eval statement>")\r\n   elif do == "FOREVER":\r\n      while True:\r\n         try:\r\n            lexer(sub(val), filename="<forever loop>")\r\n         except KeyboardInterrupt:\r\n            break\r\n   elif do == "INITAPP":\r\n      tkinter_win_ids[val] = tkinter.Tk()\r\n      tkinter_win_ids[val].title("Picturesque")\r\n   elif do == "WININIT":\r\n      args = shlex.split(val)\r\n      tkinter_win_ids[args[1]] = tkinter.TopLevel(tkinter_win_ids[args[0]])\r\n      tkinter_win_ids[args[1]].title("Picturesque")\r\n   elif do == "WINTITLE":\r\n      args = shlex.split(val)\r\n      try:\r\n         tkinter_win_ids[args[0]].title(args[1])\r\n      except KeyError:\r\n         raise ipic.errors.PicturesqueWindowNotFoundException(f"The window {shlex.quote(args[0])} does not exist. (line {lineno}, file {filename if filename != None else \'<console>\'})")\r\n   elif do == "LOOPWIN":\r\n      try:\r\n         tkinter_win_ids[val].mainloop()\r\n      except KeyboardInterrupt:\r\n         pass\r\n   elif do == "CLOSEWIN":\r\n      tkinter_win_ids[val].destroy()\r\n   elif do == "BTN":\r\n      args = json.loads(val)\r\n      tkinter_win_ids[args["NAME"]] = tkinter.Button(tkinter_win_ids[args["PARENT"]], text=args["TEXT"], command=lambda *a: lexer(args["ONCLICK"].replace(",", ";").replace("\'", ","), filename="<window event>"))\r\n      # define helper procedures\r\n      proc_dict[f"{args[\'NAME\']}.invoke".upper()] = (\r\n         range(2), (lambda pos, text: \r\n            tkinter_win_ids[args["NAME"]].invoke()\r\n         ), \r\n         PROC_TYPE_PY\r\n      )\r\n      tkinter_win_ids[args["NAME"]].pack()\r\n   elif do == "SBTN":\r\n      args = json.loads(val)\r\n      tkinter_win_ids[args["NAME"]] = tkinter.ttk.Button(tkinter_win_ids[args["PARENT"]], text=args["TEXT"], command=lambda *a: lexer(args["ONCLICK"].replace(",", ";").replace("\'", ","), filename="<window event>"))\r\n      # define helper procedures\r\n      proc_dict[f"{args[\'NAME\']}.invoke".upper()] = (\r\n         range(2), (lambda pos, text: \r\n            tkinter_win_ids[args["NAME"]].invoke()\r\n         ), \r\n         PROC_TYPE_PY\r\n      )\r\n      tkinter_win_ids[args["NAME"]].pack()\r\n   elif do == "LBL":\r\n      args = json.loads(val)\r\n      tkinter.Label(tkinter_win_ids[args["PARENT"]], text=args["TEXT"]).pack()\r\n   elif do == "IMG":\r\n      args = json.loads(val)\r\n      image = tkinter.PhotoImage(file=args["IMAGE"])\r\n      tkinter.Label(tkinter_win_ids[args["PARENT"]], image=image).pack()\r\n   elif do == "TXT":\r\n      args = json.loads(val)\r\n      tkinter_win_ids[args["NAME"]] = tkinter.Text(tkinter_win_ids[args["PARENT"]], width=args["WIDTH"], height=args["HEIGHT"])\r\n      # define helper procedures\r\n      proc_dict[f"{args[\'NAME\']}.insert".upper()] = (range(2), lambda pos, text: tkinter_win_ids[args["NAME"]].insert(pos.lower(), text), PROC_TYPE_PY)\r\n      tkinter_win_ids[args["NAME"]].pack()\r\n   elif do == "ENTRY":\r\n      args = json.loads(val)\r\n      tkinter_win_ids[args["NAME"]] = tkinter.Entry(tkinter_win_ids[args["PARENT"]])\r\n      # define helper procedures\r\n      proc_dict[f"{args[\'NAME\']}.insert".upper()] = (range(2), lambda pos, text: tkinter_win_ids[args["NAME"]].insert(pos.lower(), text), PROC_TYPE_PY)\r\n      tkinter_win_ids[args["NAME"]].pack()\r\n   elif do == "SENTRY":\r\n      args = json.loads(val)\r\n      tkinter_win_ids[args["NAME"]] = tkinter.ttk.Entry(tkinter_win_ids[args["PARENT"]])\r\n      # define helper procedures\r\n      proc_dict[f"{args[\'NAME\']}.insert".upper()] = (range(2), lambda pos, text: tkinter_win_ids[args["NAME"]].insert(pos.lower(), text), PROC_TYPE_PY)\r\n      tkinter_win_ids[args["NAME"]].pack()\r\n   elif do == "SCROLLTXT":\r\n      args = json.loads(val)\r\n      tkinter_win_ids[args["NAME"]] = tkinter.scrolledtext.ScrolledText(tkinter_win_ids[args["PARENT"]], width=args["WIDTH"], height=args["HEIGHT"])\r\n      # define helper procedures\r\n      proc_dict[f"{args[\'NAME\']}.insert".upper()] = (range(2), lambda pos, text: tkinter_win_ids[args["NAME"]].insert(pos.lower(), text), PROC_TYPE_PY)\r\n      tkinter_win_ids[args["NAME"]].pack()\r\n   elif do == "FRM":\r\n      args = json.loads(val)\r\n      tkinter_win_ids[args["NAME"]] = tkinter.ttk.Frame(tkinter_win_ids[args["PARENT"]])\r\n      tkinter_win_ids[args["NAME"]].pack()\r\n   elif do == "INFO":\r\n      tkinter.messagebox.showinfo(val[:val.find(" | ")], val[val.find(" | ")+3:])\r\n   elif do == "WRITE":\r\n      iturtle.write(val)\r\n   elif do == "DOTCL":\r\n      argsx = shlex.split(val)\r\n      argsy = shlex.split(line)\r\n      if tkinter_win_ids[argsx[0]].__class__.__name__ == "Tk":\r\n         tkinter_win_ids[argsx[0]].tk.eval(argsy[2])\r\n      else:\r\n         raise ipic.errors.PicturesqueInvalidWidgetException(f"Invalid object for command \\"dotcl\\". (line {lineno}, file {filename if filename != None else \'<console>\'})")\r\n   elif do == "SCREEN.IMAGE":\r\n      iturtle.getscreen().bgpic(ipic.path.path_insensitive(val))\r\n   elif do == "WEBSITE.OPEN":\r\n      webbrowser.open(shlex.split(line)[1])\r\n   elif do == "WEBSITE.OPENWIN":\r\n      webbrowser.open_new(shlex.split(line)[1])\r\n   elif do == "WEBSITE.OPENTAB":\r\n      webbrowser.open_new_tab(shlex.split(line)[1])\r\n   elif do == "PROFILE":\r\n      pr = profile.Profile()\r\n      pr.runctx(f"lexer({val.replace(\',\', \';\').replace(\'\\\'\', \',\')!r})", globals(), locals())\r\n      try: pr.disable()\r\n      except: pass\r\n      s = io.StringIO()\r\n      sortby = pstats.SortKey.CUMULATIVE\r\n      ps = pstats.Stats(pr, stream=s).sort_stats(sortby)\r\n      ps.print_stats()\r\n      out.output(s.getvalue())\r\n   elif do == "CLEARTERM":\r\n      out.requestclearscreen()\r\n   elif do == "WINSOUND.PLAYALIAS":\r\n      if platform.system() == "Windows":\r\n          winsound.PlaySound(val, winsound.SND_ALIAS)\r\n      else:\r\n          raise ipic.errors.PicturesqueInvalidOSException("Your operating system has to be Windows for this command to work.")\r\n   elif do == "WINSOUND.PLAYALIASASYNC":\r\n      if platform.system() == "Windows":\r\n          winsound.PlaySound(val, winsound.SND_ALIAS | winsound.SND_ASYNC)\r\n      else:\r\n          raise ipic.errors.PicturesqueInvalidOSException("Your operating system has to be Windows for this command to work.")\r\n   elif do == "WINSOUND.STOPALL":\r\n      if platform.system() == "Windows":\r\n          winsound.PlaySound(None, 0)\r\n      else:\r\n          raise ipic.errors.PicturesqueInvalidOSException("Your operating system has to be Windows for this command to work.")\r\n   elif do == "WINSOUND.LOOPALIASASYNC":\r\n      if platform.system() == "Windows":\r\n          winsound.PlaySound(val, winsound.SND_ALIAS | winsound.SND_ASYNC | winsound.SND_LOOP)\r\n      else:\r\n          raise ipic.errors.PicturesqueInvalidOSException("Your operating system has to be Windows for this command to work.")\r\n   elif do == "WINSOUND.PLAYFILE":\r\n      if platform.system() == "Windows":\r\n          winsound.PlaySound(ipic.path.path_insensitive(val), winsound.SND_FILENAME)\r\n      else:\r\n          raise ipic.errors.PicturesqueInvalidOSException("Your operating system has to be Windows for this command to work.")\r\n   elif do == "WINSOUND.PLAYFILEASYNC":\r\n      if platform.system() == "Windows":\r\n          winsound.PlaySound(ipic.path.path_insensitive(val), winsound.SND_FILENAME | winsound.SND_ASYNC)\r\n      else:\r\n          raise ipic.errors.PicturesqueInvalidOSException("Your operating system has to be Windows for this command to work.")\r\n   elif do == "WINSOUND.LOOPFILEASYNC":\r\n      if platform.system() == "Windows":\r\n          winsound.PlaySound(ipic.path.path_insensitive(val), winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_LOOP)\r\n      else:\r\n          raise ipic.errors.PicturesqueInvalidOSException("Your operating system has to be Windows for this command to work.")\r\n   elif do == "FTP.OPEN":\r\n      try:\r\n         singlevar_list[SVLIST_IDX_FTP] = ftplib.FTP(line[line.find(" ")+1:])\r\n      except importlib.import_module("socket").gaierror:\r\n         raise ipic.errors.PicturesqueInvalidURLException(f"The URL {line[line.find(\' \')+1:]!r} is invalid.")\r\n      except ftplib.all_errors as err:\r\n         out.output(str(err))\r\n   elif do == "FTP.LOGIN":\r\n      try:\r\n         if not len(val.split(" ")) > 0:\r\n            out.output(singlevar_list[SVLIST_IDX_FTP].login())\r\n         else:\r\n            csval = line[line.find(" "):]\r\n            args = csval.split(" ")\r\n            out.output(singlevar_list[SVLIST_IDX_FTP].login(args[0], args[1]))\r\n      except ftplib.all_errors as err:\r\n         out.output(str(err))\r\n   elif do == "FTP.CD":\r\n      try:\r\n         out.output(singlevar_list[SVLIST_IDX_FTP].cwd(line[line.find(" ")+1:]))\r\n      except ftplib.all_errors as err:\r\n         out.output(str(err))\r\n   elif do == "FTP.LSDIR":\r\n      try:\r\n         singlevar_list[SVLIST_IDX_FTP].dir(".", out.output)\r\n      except ftplib.all_errors as err:\r\n         out.output(str(err))\r\n   elif do == "FTP.CLOSE":\r\n      try:\r\n         out.output(singlevar_list[SVLIST_IDX_FTP].quit())\r\n         singlevar_list[SVLIST_IDX_FTP] = None\r\n      except ftplib.all_errors as err:\r\n         out.output(str(err))\r\n   elif do == "FTP.TRANSFER":\r\n      try:\r\n         with open(shlex.split(line[line.find(" ")+1:])[1], \'wb\') as fp:\r\n            out.output(singlevar_list[SVLIST_IDX_FTP].retrbinary(f\'RETR {line[line.find(" ")+1:]}\', fp.write))\r\n      except ftplib.all_errors as err:\r\n         out.output(str(err))\r\n   elif do == "LOADINI":\r\n      args = val.split(" ")\r\n      cfg = configparser.ConfigParser(allow_no_value=True)\r\n      cfg.read(ipic.path.path_insensitive(args[1]))\r\n      var_dict[args[0]] = f"""configuration file (from loadini) -> {ipic.path.path_insensitive(args[1])}\r\nsections: {", ".join(cfg.sections())}"""\r\n      for x in cfg.sections():\r\n         var_dict[f"{args[0]}[{x}]".upper()] = f"""configuration file section (from loadini) -> {ipic.path.path_insensitive(args[1])} ({x})\r\noptions: {", ".join([z for z in cfg[x]])}"""\r\n         for y in cfg[x]:\r\n             var_dict[f"{args[0]}[{x}][{y}]".upper()] = cfg[x][y]\r\n   elif do == "WRAP":\r\n      for x in textwrap.wrap(val):\r\n         out.output(x)\r\n   elif do == "LOADCSV":\r\n      args = val.split(" ")\r\n      with open(ipic.path.path_insensitive(args[1])) as csvfile:\r\n         reader = csv.reader(csvfile)\r\n         var_repllist = []\r\n         rows = [x for x in reader]\r\n         for row_n in range(len(rows)):\r\n            var_dict[f"{args[0]}[{row_n}]".upper()] = ", ".join(rows[row_n])\r\n            var_repllist.append(rows[row_n])\r\n            cols = [x for x in rows[row_n]]\r\n            for col_n in range(len(cols)):\r\n               var_dict[f"{args[0]}[{row_n}][{col_n}]".upper()] = cols[col_n]\r\n         var_dict[args[0]] = ipic.table.table(var_repllist)\r\n   elif do == "LOADPLISTXML":\r\n      args = val.split(" ")\r\n      with open(ipic.path.path_insensitive(args[1]), "rb") as plistfile:\r\n         plist = plistlib.load(plistfile, fmt=plistlib.FMT_XML)\r\n         def arrayrepr(array, isnested=False):\r\n            def checkval(the_val, num):\r\n               if the_val.__class__.__name__ == "dict":\r\n                  return f"configuration tree (from plist) -> {ipic.path.path_insensitive(args[1])} (branch: {basename}[{num}])"\r\n               elif the_val.__class__.__name__ == "list":\r\n                  return arrayrepr(array[num], isnested=True)\r\n               elif the_val.__class__.__name__ == "bool":\r\n                  return ipic.type.boolean(plist[x])\r\n               elif the_val.__class__.__name__ == "bytes":\r\n                  return the_val.decode("utf-8")\r\n               else:\r\n                  return str(the_val)\r\n            return ("(" if isnested else "") + ", ".join([checkval(array[x], x) for x in range(len(array))]) + (")" if isnested else "")\r\n         def loadarray(array, basename=args[0], isnested=False):\r\n            var_dict[basename.upper()] = arrayrepr(array)\r\n            for x in range(len(array)):\r\n               if array[x].__class__.__name__ == "dict":\r\n                  loadplist(array[x], basename=f"{basename}[{x}]")\r\n               elif array[x].__class__.__name__ == "list":\r\n                  loadarray(array[x], basename=f"{basename}[{x}]")\r\n               elif array[x].__class__.__name__ == "bool":\r\n                  var_dict[f"{basename}[{x}]".upper()] = ipic.type.boolean(plist[x])\r\n               elif array[x].__class__.__name__ == "bytes":\r\n                  var_dict[f"{basename}[{x}]".upper()] = plist[x].decode("utf-8")\r\n               else:\r\n                  var_dict[f"{basename}[{x}]".upper()] = array[x]\r\n         def loadplist(plist, basename=args[0]):\r\n            var_dict[f"{basename}".upper()] = f"""configuration tree (from plist) -> {ipic.path.path_insensitive(args[1])} (branch: {basename})\r\nkeys: {", ".join([x for x in plist])}"""\r\n            for x in plist:\r\n               if plist[x].__class__.__name__ == "dict":\r\n                   loadplist(plist[x], basename=f"{basename}[{x}]")\r\n               elif plist[x].__class__.__name__ == "list":\r\n                   loadarray(plist[x], basename=f"{basename}[{x}]")\r\n               elif plist[x].__class__.__name__ == "bool":\r\n                   var_dict[f"{basename}[{x}]".upper()] = ipic.type.boolean(plist[x])\r\n               else:\r\n                   var_dict[f"{basename}[{x}]".upper()] = plist[x]\r\n         loadplist(plist)\r\n   elif do == "UNIXDB.OPEN":\r\n      singlevar_list[SVLIST_IDX_UNIXDB] = dbm.open(line[line.find(" ")+1:], \'c\')\r\n   elif do == "UNIXDB.SETITEM":\r\n      args = shlex.split(val)\r\n      singlevar_list[SVLIST_IDX_UNIXDB][args[0]] = args[1]\r\n   elif do == "UNIXDB.CLOSE":\r\n      singlevar_list[SVLIST_IDX_UNIXDB].close()\r\n      singlevar_list[SVLIST_IDX_UNIXDB] = None\r\n   elif do == "UNIXDB.GETITEM":\r\n      out.output(singlevar_list[SVLIST_IDX_UNIXDB].get(val, b\'(item not present)\').decode("utf-8"))\r\n   elif do == "SQL.OPEN":\r\n      singlevar_list[SVLIST_IDX_SQLDB] = sqlite3.connect(line[line.find(" ")+1:])\r\n      singlevar_list[SVLIST_IDX_SQLCUR] = singlevar_list[SVLIST_IDX_SQLDB].cursor()\r\n   elif do == "SQL.RUN":\r\n      res = singlevar_list[SVLIST_IDX_SQLCUR].execute(line[line.find(" ")+1:])\r\n      try:\r\n         out.output(ipic.table.htable([col[0] for col in res.description], res.fetchall()))\r\n      except:\r\n         pass\r\n   elif do == "SQL.SAVE":\r\n      res = singlevar_list[SVLIST_IDX_SQLDB].commit()\r\n   elif do == "SQL.CLOSE":\r\n      singlevar_list[SVLIST_IDX_SQLDB].close()\r\n      singlevar_list[SVLIST_IDX_SQLDB] = None\r\n      singlevar_list[SVLIST_IDX_SQLCUR] = None\r\n   elif do == "PROC":\r\n      name = val[:val.find(":")][:val.find(" ")]\r\n      args_str = val[val.find(" ")+1:val.find(":")].strip()\r\n      args = tuple(args_str.split(" ")) if not args_str == "" else ()\r\n      csval = line[line.find(" "):]\r\n      code = sub(csval[csval.find(":")+1:])\r\n      proc_dict[name] = (args, code, PROC_TYPE_PIC)\r\n   elif do == "LICENSE":\r\n      out.output("""MIT License\r\n\r\nCopyright (c) 2024 Ridwan bin Mohammad \r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the "Software"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.""")\r\n   elif do == "ONEXIT":\r\n      atexit.register(lambda: lexer(sub(line[line.find(" "):])))\r\n   elif do == "WIDTH":\r\n      iturtle.width(int(val))\r\n   elif do == "SERVER":\r\n      args = json.loads(line[line.find(" ")+1:])\r\n      def web_server(environ, start_response):\r\n         def handle_response(route):\r\n            headers = []\r\n            for key in args["routes"][route]["headers"]:\r\n                headers.append((key, sub(args["routes"][route]["headers"][key])))\r\n            start_response("200 OK", headers)\r\n            return [args["routes"][route]["text"].encode(args["routes"][route]["encoding"])]\r\n         for route in args["routes"]:\r\n            if environ["PATH_INFO"] == route:\r\n                try:\r\n                   return handle_response(args["routes"][route]["display"])\r\n                except KeyError:\r\n                   return handle_response(route)\r\n         start_response("404 Not Found", [("Content-Type", "text/html; encoding=utf-8")])\r\n         return ["""<!DOCTYPE html>\r\n<html>\r\n<body>\r\n\r\n<h1>Picturesque <code>server</code> command</h1>\r\n<h2>Error 404</h2>\r\n<p>The page you requested was not found.</h1>\r\n\r\n</body>\r\n</html>""".encode("utf-8")]\r\n      class RequestHandler(wsgiref.simple_server.WSGIRequestHandler):\r\n         def log_message(self, format, *args):\r\n            out.output("%s - - [%s] %s" % (self.client_address[0], self.log_date_time_string(), format % args))\r\n         def get_stderr(self):\r\n            return self.StdErr()\r\n         class StdErr:\r\n            def write(self, text):\r\n               out.strerror(text)\r\n            def flush(self):\r\n               out.flush()\r\n      with wsgiref.simple_server.make_server(\'\', args["port"], web_server, handler_class=RequestHandler) as httpd:\r\n         out.output(f"Serving HTTP on port {args[\'port\']}...")\r\n         try:\r\n            httpd.serve_forever()\r\n         except KeyboardInterrupt:\r\n            pass\r\n   elif do == "LOADTOML":\r\n      name = val[:val.find(" ")]\r\n      file = ipic.path.path_insensitive(val[val.find(" ")+1:])\r\n      doc = tomllib.load(open(file, "rb"))\r\n      def arrayrepr(array, nested=False):\r\n          def checkval(item):\r\n              if item.__class__.__name__ == "dict":\r\n                 return "configuration tree (from loadtoml)"\r\n              elif item.__class__.__name__ == "list":\r\n                 return arrayrepr(item, nested=True)\r\n              else:\r\n                 return str(item)\r\n          return ("(" if nested else "") + ", ".join([checkval(x) for x in array]) + (")" if nested else "") \r\n      def parse_array(array, basename=name):\r\n          var_dict[basename.upper()] = arrayrepr(array)\r\n          for idx in range(len(array)):\r\n              value = array[idx]\r\n              if value.__class__.__name__ == "dict":\r\n                 parse_table(value, basename=f"{basename}[{idx}]")\r\n              elif value.__class__.__name__ == "list":\r\n                 parse_array(value, basename=f"{basename}[{idx}]")\r\n              else:\r\n                 var_dict[f"{basename}[{idx}]".upper()] = str(value)\r\n      def parse_table(table, basename=name):\r\n          var_dict[basename.upper()] = f"""configuration tree (from loadtoml) -> {ipic.path.path_insensitive(file)}  (branch: {basename})\r\nkeys: {", ".join([x for x in table])}"""\r\n          for key in table:\r\n              value = table[key]\r\n              if value.__class__.__name__ == "dict":\r\n                 parse_table(value, basename=f"{basename}[{key}]")\r\n              elif value.__class__.__name__ == "list":\r\n                 parse_array(value, basename=f"{basename}[{key}]")\r\n              else:\r\n                 var_dict[f"{basename}[{key}]".upper()] = str(value)\r\n      parse_table(doc)\r\n   elif do == "LOADNETRC":\r\n      name = val[:val.find(" ")]\r\n      file = ipic.path.path_insensitive(val[val.find(" ")+1:])\r\n      doc = netrc.netrc(file)\r\n      var_dict[name.upper()] = f"""netrc file (from loadnetrc) -> {file}\r\nhosts: {", ".join([x for x in doc.hosts])}"""\r\n      for host in doc.hosts:\r\n         var_dict[f"{name}[{host}]".upper()] = f"""netrc host: {host} (from loadnetrc) -> {file}\r\nusername: {doc.hosts[host][0]}\r\npassword: {doc.hosts[host][2]}"""\r\n         var_dict[f"{name}[{host}].username".upper()] = doc.hosts[host][0]\r\n         var_dict[f"{name}[{host}].password".upper()] = doc.hosts[host][2]\r\n   elif do == "OPENURL":\r\n      csval = line[line.find(" ")+1:]\r\n      name = val[:val.find(" ")]\r\n      file = csval[csval.find(" ")+1:]\r\n      with urllib.request.urlopen(file) as response:\r\n         var_dict[name.upper()] = f"web response (from urlopen) -> {file}{f\' <--> {response.geturl()}\' if response.geturl() != file else \'\'}"\r\n         var_dict[f"{name}.text".upper()] = response.read().decode()\r\n         var_dict[f"{name}.headers".upper()] = f"web response headers: {json.dumps(dict(response.headers))}"\r\n         for key in response.headers:\r\n             value = response.headers[key]\r\n             var_dict[f"{name}.headers[{key}]".upper()] = value\r\n   elif do == "RGB2HSV":\r\n      name = val[:val.find(" ")]\r\n      icolor = val[val.find(" ")+1:].split(" ")\r\n      ocolor = colorsys.rgb_to_hsv(*(float(x) for x in icolor))\r\n      var_dict[name.upper()] = " ".join([str(x) for x in ocolor])\r\n   elif do == "HSV2RGB":\r\n      name = val[:val.find(" ")]\r\n      icolor = val[val.find(" ")+1:].split(" ")\r\n      ocolor = colorsys.hsv_to_rgb(*(float(x) for x in icolor))\r\n      var_dict[name.upper()] = " ".join([str(x) for x in ocolor])\r\n   elif do == "RGB2HLS":\r\n      name = val[:val.find(" ")]\r\n      icolor = val[val.find(" ")+1:].split(" ")\r\n      ocolor = colorsys.rgb_to_hls(*(float(x) for x in icolor))\r\n      var_dict[name.upper()] = " ".join([str(x) for x in ocolor])\r\n   elif do == "HLS2RGB":\r\n      name = val[:val.find(" ")]\r\n      icolor = val[val.find(" ")+1:].split(" ")\r\n      ocolor = colorsys.hls_to_rgb(*(float(x) for x in icolor))\r\n      var_dict[name.upper()] = " ".join([str(x) for x in ocolor])\r\n   elif do == "RGB2YIQ":\r\n      name = val[:val.find(" ")]\r\n      icolor = val[val.find(" ")+1:].split(" ")\r\n      ocolor = colorsys.rgb_to_yiq(*(float(x) for x in icolor))\r\n      var_dict[name.upper()] = " ".join([str(x) for x in ocolor])\r\n   elif do == "YIQ2RGB":\r\n      name = val[:val.find(" ")]\r\n      icolor = val[val.find(" ")+1:].split(" ")\r\n      ocolor = colorsys.hls_to_rgb(*(float(x) for x in icolor))\r\n      var_dict[name.upper()] = " ".join([str(x) for x in ocolor])\r\n   elif do == "HASH":\r\n      occur = ipic.string.findall(val, " ")\r\n      name = val[:occur[0]]\r\n      algo = val[occur[0]+1:occur[1]]\r\n      to_encode = val[occur[1]+1:]\r\n      var_dict[name.upper()] = hashlib.new(algo, to_encode.encode()).hexdigest()\r\n   elif do == "USING":\r\n      for x in val.split(","):\r\n          ns = importlib.import_module(f"ipic.ns.builtins.{x.strip()}")\r\n          ns_list[x] = ipic.ns.getnsclass(ns)(\r\n             stamps = stamps,\r\n             turtle_gone = turtle_gone,\r\n             tkinter_win_ids = tkinter_win_ids,\r\n             PROC_TYPE_PIC = PROC_TYPE_PIC,\r\n             PROC_TYPE_PY = PROC_TYPE_PY,\r\n             var_dict = var_dict,\r\n             proc_dict = proc_dict,\r\n             singlevar_list = singlevar_list,\r\n             out = out,\r\n             ns_sysvar = ns_sys_var,\r\n             ns_list = ns_list,\r\n          )\r\n   elif do == "USING-FILE":\r\n      for x in [y for y in csv.reader([val])][0]:\r\n          ns = ipic.ns.import_module_from_file_path(ipic.path.path_insensitive(x))\r\n          ns_list[ns.__name__] = ipic.ns.getnsclass(ns)(\r\n             stamps = stamps,\r\n             turtle_gone = turtle_gone,\r\n             tkinter_win_ids = tkinter_win_ids,\r\n             PROC_TYPE_PIC = PROC_TYPE_PIC,\r\n             PROC_TYPE_PY = PROC_TYPE_PY,\r\n             var_dict = var_dict,\r\n             proc_dict = proc_dict,\r\n             singlevar_list = singlevar_list,\r\n             out = out,\r\n             ns_sysvar = ns_sys_var,\r\n             ns_list = ns_list,\r\n          )\r\n   elif do.startswith("%") and do[1:] in proc_dict:\r\n      args = shlex.split(val)\r\n      proc = do[1:]\r\n      if len(args) > len(proc_dict[proc][PROC_IDX_ARGS]): \r\n         raise ipic.errors.PicturesqueTooManyArgumentsException(f"Too many arguments for procedure {proc!r}. (line {lineno})")\r\n      if len(args) < len(proc_dict[proc][PROC_IDX_ARGS]):\r\n         raise ipic.errors.PicturesqueTooLittleArgumentsException(f"Too little arguments for procedure {proc!r}. (line {lineno})")\r\n      if proc_dict[proc][PROC_IDX_TYPE] == PROC_TYPE_PIC:\r\n         lexer(proc_dict[proc][PROC_IDX_CODE], filename=filename, proc=proc, args=ipic.type.py_list2dict(proc_dict[proc][PROC_IDX_ARGS], args))\r\n      elif proc_dict[proc][PROC_IDX_TYPE] == PROC_TYPE_PY:\r\n         proc_dict[proc][PROC_IDX_CODE](*(x for x in args))\r\n   else:\r\n      # namespace commands\r\n      for ns in ns_list:\r\n         try:\r\n            ns_list[ns].__interpret__(do, val, line[line.find(" ")+1:])\r\n            return\r\n         except ipic.errors.PicturesqueCommandNotInNamespaceException:\r\n            pass\r\n      markers = ""\r\n      for x in range(len(do)):\r\n         markers += "^"\r\n      for x in line:\r\n         if x in string.whitespace:\r\n             markers = x + markers\r\n         else: \r\n             break\r\n      raise ipic.errors.PicturesqueUnreconizedCommandException(f"""Error: Unrecognized command at {filename}:{lineno}, in {proc}\r\n  {line[1:] if line.startswith("\\n") else line}\r\n  {markers[1:] if markers.startswith("\\n") else markers}""")\r\ndef lexer(program, is_console=False, filename="<console>", is_artist=False, proc="<global>", args={}):\r\n   #*~----------------------------~( Initialization )~-----------------------------------------~*#\r\n   global stamps\r\n   if program.endswith(";"):\r\n      program = program[0:-1]\r\n   cmd_list = program.split(";")\r\n   #*~-------------------------~( End of initialization )~-------------------------------------~*#\r\n   #*~------------------------------~( Main loop )~--------------------------------------------~*#\r\n   for x in range(len(cmd_list)):\r\n      cmd = cmd_list[x]\r\n      line = cmd\r\n      cmd = cmd.strip()\r\n      cmd = cmd.upper()\r\n      cmd_len = len(cmd.split(" "))\r\n      if cmd_len == 0 or len(cmd) == 0 or cmd[0] == "~":\r\n         continue\r\n      cmd_type = cmd\r\n      num = ""\r\n      if cmd_len > 1:\r\n         num = cmd[cmd.find(" ")+1:]\r\n         cmd_type = cmd[:cmd.find(" ")]\r\n      def defsysvar(nm, val, num, todo=None):\r\n          if "{$"+nm.upper()+"}" in num:\r\n             if todo == None:\r\n                return num.replace("{$"+nm.upper()+"}", str(val))\r\n             else:\r\n                return num.replace("{$"+nm.upper()+"}", str(todo(val)))\r\n          else:\r\n             return num\r\n      #*~---------------------------~( Variables )~-----------------------------------------~*#\r\n      if not turtle_gone:\r\n          num = defsysvar("POS", iturtle.position(), num)\r\n          num = defsysvar("X", iturtle.xcor(), num)\r\n          num = defsysvar("Y", iturtle.ycor(), num)\r\n          num = defsysvar("DOWN", ipic.type.boolean(iturtle.isdown()), num)\r\n          num = defsysvar("OUTLINE", iturtle.pencolor(), num)\r\n          num = defsysvar("FILL", iturtle.fillcolor(), num)\r\n          num = defsysvar("COLOR", iturtle.color(), num)\r\n          num = defsysvar("VISIBLE", iturtle.isvisible(), num)\r\n          num = defsysvar("TURTLE_SHAPE_POLYGONAL_POINTS", iturtle.get_shapepoly(), num)\r\n          num = defsysvar("BGCOLOR", iturtle.getscreen().bgcolor(), num)\r\n          num = defsysvar("BGIMAGE", iturtle.getscreen().bgpic(), num)\r\n          num = defsysvar("WINHEIGHT", iturtle.getscreen().window_height(), num)\r\n          num = defsysvar("WINWIDTH", iturtle.getscreen().window_width(), num)\r\n          num = defsysvar("STAMPS", stamps, num)\r\n          num = defsysvar("MODE", iturtle.mode(), num)\r\n          num = defsysvar("shape", iturtle.shape(), num)\r\n          num = defsysvar("bgpic", iturtle.getscreen().bgpic(), num)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = defsysvar("tk_version", tkinter.TkVersion, num)\r\n      num = defsysvar("tk_ext_version", tkinter.Tcl().call("info", "patchlevel"), num)\r\n      num = defsysvar("py_version", sysconfig.get_python_version(), num)\r\n      num = defsysvar("py_ext_version", "%d.%d.%d" % sys.version_info[:3], num)\r\n      num = defsysvar("py_sup_ext_version", sys.version, num)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = defsysvar("argv", ", ".join(sys.argv), num)\r\n      for x in range(len(sys.argv)):\r\n         num = defsysvar(f"argv[{x}]", sys.argv[x], num)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      try:\r\n         num = defsysvar("ftp.cwd", singlevar_list[SVLIST_IDX_FTP].pwd(), num)\r\n         num = defsysvar("ftp.welcome", singlevar_list[SVLIST_IDX_FTP].getwelcome(), num)\r\n      except:\r\n         pass\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = defsysvar("cli.input", input, num, todo=TODO_CALL)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = defsysvar("askopenfile", tkinter.filedialog.askopenfilename, num, todo=TODO_CALL)\r\n      num = defsysvar("askdir", tkinter.filedialog.askdirectory, num, todo=TODO_CALL)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      def pic_guiinput():\r\n         if turtle_gone:\r\n            iturtle.Turtle._screen = None  # force recreation of singleton Screen object\r\n            iturtle.TurtleScreen._RUNNING = True  # only set upon TurtleScreen() definition\r\n         inputtxt = iturtle.getscreen().textinput("Picturesque", "This program wants to ask you something.")\r\n         if turtle_gone:\r\n            iturtle.bye()\r\n         return inputtxt if inputtxt is not None else ""\r\n      num = defsysvar("gui.input", pic_guiinput, num, todo=TODO_CALL)\r\n      def pic_guinuminput():\r\n         if turtle_gone:\r\n            iturtle.Turtle._screen = None  # force recreation of singleton Screen object\r\n            iturtle.TurtleScreen._RUNNING = True  # only set upon TurtleScreen() definition\r\n         inputtxt = iturtle.getscreen().numinput(val[:val.find(" | ")], val[val.find(" | ")+3:])\r\n         if turtle_gone:\r\n            iturtle.bye()\r\n         return inputtxt if inputtxt is not None else ""\r\n      num = defsysvar("gui.numinput", pic_guinuminput, num, todo=TODO_CALL)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      def pic_askcolor():\r\n         color = tkinter.colorchooser.askcolor()\r\n         return " ".join([str(x) for x in color[0]]) if color != (None, None) else ""\r\n      num = defsysvar("askcolor", pic_askcolor, num, todo=TODO_CALL)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      for pic_class in class_dict:\r\n         num = defsysvar(class_dict[pic_class].__class__.__name__, lambda: class_dict[pic_class].new(proc_dict, var_dict), num, todo=TODO_CALL)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = defsysvar("getpass", lambda: getpass.getpass(""), num, todo=TODO_CALL)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = defsysvar("json.true", "true", num)\r\n      num = defsysvar("json.false", "false", num)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      for i in args:\r\n         num = defsysvar(f"args[{i}]", args[i], num)\r\n      num = defsysvar("args", ipic.type.dictionary(args), num)\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      for i in ns_sys_var:\r\n         num = defsysvar(i, ns_sys_var[i][0], num, **ns_sys_var[i][1])\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = num.replace("($)", "$")\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      for i in var_dict:\r\n         num = num.replace("{%"+i+"}", str(var_dict[i]))\r\n      #*~-------------------------------------~*~-------------------------------------------~*#\r\n      num = num.replace("(%)", "%")\r\n      #*~----------------------------~( End of variables )~---------------------------------~*#\r\n      #*~------------------------------~( Interpreting )~-----------------------------------~*#\r\n      try:\r\n         interpret(cmd_type, num, x + 1, line, is_console, filename, is_artist, proc)\r\n      except Exception as err:\r\n         out.error(err)\r\n      #*~---------------------------~( End of interpreting )~-------------------------------~*#\r\n   #*~--------------------------------~( End of main loop )~-----------------------------------~*#PK\x03\x04\x14\x00\x00\x00\x00\x00b\x88\xfeXJK\xb1\xfa\xb7\x06\x00\x00\xb7\x06\x00\x00\x0b\x00\x00\x00ipic/out.pyimport ipic.errors\r\n\r\nclass PicturesqueOutputHandler:\r\n    _listeners = {\r\n       "_output": lambda e: "break",\r\n       "_error": lambda e: "break",\r\n       "_clear": lambda e: "break",\r\n       "_output_sameline": lambda e: "break",\r\n       "_error_string": lambda e: "break",\r\n       "_handle_flush": lambda e: "break"\r\n    }\r\n    _output = []\r\n    _errors = []\r\n    def bind(self, evt, func):\r\n       if evt == "output":\r\n          self._listeners["_output"] = func\r\n       elif evt == "error":\r\n          self._listeners["_error"] = func\r\n       elif evt == "onrequestclearscreen":\r\n          self._listeners["_clear"] = func\r\n       elif evt == "output_sameline":\r\n          self._listeners["_output_sameline"] = func\r\n       elif evt == "error_string":\r\n          self._listeners["_error_string"] = func\r\n       elif evt == "flush":\r\n          self._listeners["_handle_flush"] = func\r\n       else:\r\n          raise ipic.errors.PicturesqueUnreconizedEventException(repr(evt))\r\n    def output(self, text):\r\n       self._output.append(text)\r\n       self._listeners["_output"](text)\r\n    def output_sameline(self, text):\r\n       self._output[-1] += text\r\n       self._listeners["_output_sameline"](text)\r\n    def error(self, err):\r\n       self._errors.append(err)\r\n       self._listeners["_error"](err)\r\n    def strerror(self, err):\r\n       self._errors.append(err)\r\n       self._listeners["_error_string"](err)\r\n    def requestclearscreen(self):\r\n       self._listeners["_clear"]()\r\n    def flush(self):\r\n       self._listeners["_handle_flush"]()\r\n    def getoutput(self):\r\n       return self._output\r\n    def geterrors(self):\r\n       return self._errors\r\n    def __str__(self):\r\n       return "\\n".join(self._output)PK\x03\x04\x14\x00\x00\x00\x00\x00vu\xe5Xe\xf3\x02\xd4n\x05\x00\x00n\x05\x00\x00\x0c\x00\x00\x00ipic/path.pyimport os\r\n#*~------------------------~( Credit to stackoverflow )~-----------------------------~*#\r\ndef path_insensitive(path):\r\n    return _path_insensitive(path) or path\r\ndef _path_insensitive(path):\r\n    """\r\n    Recursive part of path_insensitive to do the work.\r\n    """\r\n\r\n    if path == \'\' or os.path.exists(path):\r\n        return path\r\n\r\n    base = os.path.basename(path)  # may be a directory or a file\r\n    dirname = os.path.dirname(path)\r\n\r\n    suffix = \'\'\r\n    if not base:  # dir ends with a slash?\r\n        if len(dirname) < len(path):\r\n            suffix = path[:len(path) - len(dirname)]\r\n\r\n        base = os.path.basename(dirname)\r\n        dirname = os.path.dirname(dirname)\r\n\r\n    if not os.path.exists(dirname):\r\n        dirname = _path_insensitive(dirname)\r\n        if not dirname:\r\n            return\r\n\r\n    # at this point, the directory exists but not the file\r\n\r\n    try:  # we are expecting dirname to be a directory, but it could be a file\r\n        files = os.listdir(dirname)\r\n    except OSError:\r\n        return\r\n\r\n    baselow = base.lower()\r\n    try:\r\n        basefinal = next(fl for fl in files if fl.lower() == baselow)\r\n    except StopIteration:\r\n        return\r\n\r\n    if basefinal:\r\n        return os.path.join(dirname, basefinal) + suffix\r\n    else:\r\n        return\r\n#*~----------------------------~( End of credit )~-----------------------------------~*#PK\x03\x04\x14\x00\x00\x00\x00\x00\x04\xb0\xf1X\x11\xcc_\xbf \x02\x00\x00 \x02\x00\x00\r\x00\x00\x00ipic/setup.py# -*- coding: utf-8 -*-\r\nfrom setuptools import setup, find_packages\r\n\r\ntry:\r\n    long_description = open("README.rst").read()\r\nexcept IOError:\r\n    long_description = ""\r\n\r\nsetup(\r\n    name="ipic",\r\n    version="1.0.0",\r\n    description="The Picturesque programming language.",\r\n    license="MIT",\r\n    author="tiashDev",\r\n    packages=find_packages(),\r\n    install_requires=[],\r\n    long_description=long_description,\r\n    classifiers=[\r\n        "Programming Language :: Python",\r\n        "Programming Language :: Python :: 3.12",\r\n    ]\r\n)\r\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb0\x8e\x01Y\xf5~lDH\x00\x00\x00H\x00\x00\x00\x0e\x00\x00\x00ipic/string.pyfindall = lambda x, y: [i for i in range(len(x)) if x.startswith(y, i)] PK\x03\x04\x14\x00\x00\x00\x00\x00,\x8c\x1aYO\xeb\xf4\xa1\x02\x04\x00\x00\x02\x04\x00\x00\r\x00\x00\x00ipic/table.py#*~------------------------~( Credit to stackoverflow, edited )~-----------------------------~*#\r\ndef table(rows):\r\n  # find the max length of each column\r\n  max_col_lens = list(map(max, zip(*[(len(str(cell)) for cell in row) for row in rows])))\r\n\r\n  row_fstring = \'   \'.join("{: <%s}" % n for n in max_col_lens)\r\n  \r\n  retval = []\r\n  for i, row in enumerate(rows):\r\n    retval.append(row_fstring.format(*map(str, row)))\r\n  return "\\n".join(retval)\r\ndef htable(head, rows):\r\n  # find the max length of each column\r\n  max_col_lens = list(map(max, zip(*[(len(str(cell)) for cell in row) for row in rows])))\r\n\r\n  row_fstring = \'   \'.join("{: <%s}" % n for n in max_col_lens)\r\n  head_fstring = \'___\'.join("{:_<%s}" % n for n in max_col_lens)\r\n  \r\n  retval = []\r\n  retval.append(head_fstring.format(*map(str, head)))\r\n  for i, row in enumerate(rows):\r\n    retval.append(row_fstring.format(*map(str, row)))\r\n  return "\\n".join(retval)\r\n#*~--------------------------------~( End of credit )~---------------------------------------~*#PK\x03\x04\x14\x00\x00\x00\x00\x004\x02\x16YvA\xdc\xf8\xea\x04\x00\x00\xea\x04\x00\x00\x0c\x00\x00\x00ipic/type.pyimport inspect, ipic.lang, random\r\ndef boolean(x):\r\n   if x:\r\n      return "$true"\r\n   else:\r\n      return "$false"\r\ndef pbool(x):\r\n   if x.lower() == "$true":\r\n      return True\r\n   elif x.lower() == "$false":\r\n      return False\r\ndef list2dict(keys, vals):\r\n   return f"({\', \'.join([f\'{keys[x]}: {vals[x]}\' for x in range(len(keys))])})"\r\ndef py_list2dict(keys, vals):\r\n   dictobj = {}\r\n   for x in range(len(keys)):\r\n      dictobj[keys[x]] = vals[x]\r\n   return dictobj\r\ndef dictionary(dictobj):\r\n   return f"({\', \'.join([f\'{x}: {dictobj[x]}\' for x in dictobj])})"\r\n"""class Pic_class:\r\n   is_pic = True\r\n   _is_pic_const = {True: ipic.lang.PROC_TYPE_PIC, False: ipic.lang.PROC_TYPE_PY}\r\n   def new(self, proc_dict, var_dict):\r\n      print(vars(self))\r\n      for proc in vars(self): \r\n         if proc.startswith("proc_"):\r\n            proc_dict[f"{self.__class__.__name__}.{proc.removeprefix(\'proc_\')}".upper()] = (range(len(inspect.getfullargspec(vars(self)[proc])[0])), vars(self)[proc], _is_pic_const[is_pic])\r\n      for var in vars(self): \r\n         if proc.startswith("var_"):\r\n            var_dict[f"{self.__class__.__name__}.{var.removeprefix(\'var_\')}".upper()] = vars(self)[var]\r\n      return f"<Picturesque class {self.__class__.__name__!r}>\\""""PK\x03\x04\x14\x00\x00\x00\x00\x00;z\x07Y\xdd\x04\xa4\x17:\x00\x00\x00:\x00\x00\x00\x10\x00\x00\x00ipic/warnings.pyclass PicturesqueUndefinedTkWinClassWarning(Warning): passPK\x03\x04\x14\x00\x00\x00\x00\x00g\x94\x1aYM;\x12\t\t\x16\x00\x00\t\x16\x00\x00\x13\x00\x00\x00ipic/ns/__init__.py"""Implements Picturesque namespaces."""\r\nimport ipic.errors, shlex, importlib.machinery, os.path\r\n\r\nnsclasses = ["main", "Main", "ns", "Namespace"]\r\n\r\ndef cmd2meth(do):\r\n   """The function used by namespaces to turn a command name into a Python method name. The symbols and what they are turned into are described in the table below.\r\n   \r\n   =======  ===========================\r\n   Symbol   Substitute (must be exact)\r\n   =======  ===========================\r\n   .        CHAR0__\r\n   \\\\-       CHAR1__\r\n   [        CHAR2__\r\n   ]        CHAR3__\r\n   =======  ===========================\r\n   \r\n   For example:\r\n   \r\n      * if you wanted to define a command called ``hello.world``, you\'d need to define a method called :py:func:`do_helloCHAR0__world` in your :py:class:`main` class.\r\n      * if you wanted to define a command called ``hello-world``, you\'d need to define a method called :py:func:`do_helloCHAR1__world` in your :py:class:`main` class.\r\n      * if you wanted to define a command called ``hello[world]``, you\'d need to define a method called :py:func:`do_helloCHAR2__worldCHAR3__` in your :py:class:`main` class.\r\n      \r\n   Note that these examples assume that you are using a class that uses this function in their :py:func:`__interpret__` methods, as both :py:class:`CmdNamespace` and :py:class:`ShlexNamespace` do."""\r\n   do = do.lower()\r\n   escvals = [".", "-", "[", "]"]\r\n   for idx, val in enumerate(escvals):\r\n      do = do.replace(val, f"CHAR{idx}__")\r\n   do = "do_" + do\r\n   return do\r\n\r\nclass PicturesqueNamespace:\r\n   """The base class for all Picturesque namespaces.\r\n   \r\n   All Picturesque namespace files need to have a ``main`` class, and it has to be a subclass of \r\n   :py:class:`PicturesqueNamespace`. There are a few classes to make things easier, such as:\r\n   \r\n   * :py:class:`CmdNamespace`\r\n   * :py:class:`ShlexNamespace`\r\n   \r\n   These classes work by having an ``__interpret__`` method which has the signature\r\n   \r\n   code-block:: python\r\n   \r\n      def __interpret__(self, do, val, csval)\r\n   \r\n   Where ``do`` is the command name, ``val`` is the case-insensitive arguments with variables, and ``csval`` is the arguments without variables - case-sensitive.\r\n   \r\n   Note that :py:class:`PicturesqueNamespace` does not have the ``__interpret__`` method. Of course you can define\r\n   your own ``__interpret__`` method to interpret it in your own way. In that case you should extend \r\n   :py:class:`PicturesqueNamespace`, as it does not have a defined ``__interpret__`` method."""\r\n   def __init__(self,\r\n                stamps,\r\n                turtle_gone,\r\n                tkinter_win_ids,\r\n                PROC_TYPE_PIC,\r\n                PROC_TYPE_PY,\r\n                var_dict,\r\n                proc_dict,\r\n                out,\r\n                singlevar_list,\r\n                ns_sysvar,\r\n                ns_list):\r\n       self.out = out\r\n       self.stamps = stamps\r\n       self.turtle_gone = turtle_gone\r\n       self.tkinter_win_ids = tkinter_win_ids\r\n       self.PROC_TYPE_PIC = PROC_TYPE_PIC\r\n       self.PROC_TYPE_PY = PROC_TYPE_PY\r\n       self.var_dict = var_dict\r\n       self.proc_dict = proc_dict\r\n       self.singlevar_list = singlevar_list\r\n       self.sys_var = ns_sysvar\r\n       self.ns_list = ns_list\r\n       self.on_ns_init()\r\n   def on_ns_init(self):\r\n       pass\r\n\r\nclass CmdNamespace(PicturesqueNamespace):\r\n   """A base class for Picturesque namespaces, where val (the arguments with variables - case-insensitive) and \r\n   csval (the arguments without variables - case-sensitive) are passed as seperate arguments to the do_* function \r\n   for the command.\r\n   \r\n   You might like this kind of namespace if you are familiar with the ``cmd`` module."""\r\n   \r\n   def __interpret__(self, do, val, csval):\r\n       """The method used by ipic.lang to interpret Picturesque namespace commands."""\r\n       try:\r\n          getattr(self, cmd2meth(do))(val, csval)\r\n       except AttributeError as err:\r\n          if str(err).startswith(f"{self.__class__.__name__!r} object has no attribute \'{cmd2meth(do)}\'"):\r\n             raise ipic.errors.PicturesqueCommandNotInNamespaceException()\r\n          else:\r\n             raise err\r\n\r\nclass ShlexNamespace(PicturesqueNamespace):\r\n   """A base class for Picturesque namespaces, where val (the arguments with variables - case-insensitive) is\r\n   split into different arguments using ``shlex.split``, and then passed to the ``do_*`` function for the command\r\n   using the star operator.\r\n   \r\n   You might use this kind of namespace if you are a beginner."""\r\n   \r\n   def __interpret__(self, do, val, csval):\r\n       """The method used by ipic.lang to interpret Picturesque namespace commands."""\r\n       try:\r\n          getattr(self, cmd2meth(do))(*shlex.split(val))\r\n       except AttributeError as err:\r\n          if str(err).startswith(f"{self.__class__.__name__!r} object has no attribute \'{cmd2meth(do)}\'"):\r\n             raise ipic.errors.PicturesqueCommandNotInNamespaceException()\r\n          else:\r\n             raise err\r\n\r\ndef import_module_from_file_path(path, name=None):\r\n   """Import a module using a file path, instead of a module path."""\r\n   return importlib.machinery.SourceFileLoader(\r\n      name or os.path.basename(path).removesuffix(".py"),\r\n      path\r\n   ).load_module()\r\n#\r\ndef getnsclass(mod):\r\n   for nsclass in nsclasses:\r\n      if hasattr(mod, nsclass):\r\n         return getattr(mod, nsclass)\r\n   raise ipic.errors.PicturesqueNotANamespaceException(f"The Python module {mod.__name__!r} is not a Picturesque namespace, as it does not have {\', \'.join([repr(x) for x in nsclasses[:-1]])} or {nsclasses[-1]!r} classes.")PK\x03\x04\x14\x00\x00\x00\x00\x00\xf5\x8e\x08YZ#\x9a\xec~\x00\x00\x00~\x00\x00\x00\x1e\x00\x00\x00ipic/ns/builtins/HELLOWORLD.pyimport ipic.ns\r\n\r\nclass main(ipic.ns.CmdNamespace):\r\n   def do_hello(self, val, cival):\r\n      self.out.output("Hello world!")PK\x03\x04\x14\x00\x00\x00\x00\x00\xb4r\x1aYJ\xddn\xf3\x9b\t\x00\x00\x9b\t\x00\x00\x1d\x00\x00\x00ipic/ns/builtins/QT5/GRAPH.pyimport ipic.ns, pyqtgraph, json, shlex, PyQt5.QtCore\r\n\r\nclass main(ipic.ns.CmdNamespace):\r\n   def on_ns_init(self):\r\n      self.qtwdict = self.ns_list["QT5"].qtwdict\r\n      self.penstyle = {\r\n         "SOLID": PyQt5.QtCore.Qt.SolidLine,\r\n         "DASHED": PyQt5.QtCore.Qt.DashLine,\r\n         "DOTTED": PyQt5.QtCore.Qt.DotLine,\r\n         "DASHDOT": PyQt5.QtCore.Qt.DashDotLine,\r\n         "DASH2XDOT": PyQt5.QtCore.Qt.DashDotDotLine,\r\n      }\r\n   def do_qtCHAR0__plot(self, val, cival):\r\n      parsestr = val[val.find("|")+1:].strip()\r\n      data = shlex.split(val[:val.find("|")].strip())\r\n      self.qtwdict[data[0]] = pyqtgraph.PlotWidget()\r\n      xpoints = [int(x) for x in list(parsestr[:parsestr.find(" * ")].split(" "))]\r\n      if parsestr.find(" : ") >= -1:\r\n         ypoints = [int(x) for x in list(parsestr[parsestr.find(" * ")+len(" * "):parsestr.find(" : ")].split(" "))]\r\n         args = json.loads(parsestr[parsestr.find(" : ")+len(" : "):])\r\n      else:\r\n         ypoints = [int(x) for x in list(parsestr[parsestr.find(" * ")+len(" * "):].split(" "))]\r\n         args = {"ADD":True}\r\n      pnkw = {}\r\n      plkw = {}\r\n      gdkw = {"x":False,"y":False}\r\n      if args["ADD"]:\r\n         self.qtwdict[data[1]].addWidget(self.qtwdict[data[0]])\r\n      try:\r\n         self.qtwdict[data[0]].setBackground(args["BGCOLOR"].lower())\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         pnkw["color"] = args["COLOR"].lower()\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         pnkw["style"] = self.penstyle[args["STYLE"]]\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         plkw["symbol"] = args["SYMBOL"]["CODE"].lower()\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         plkw["symbolSize"] = args["SYMBOL"]["SIZE"]\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         plkw["symbolBrush"] = args["SYMBOL"]["BRUSH"].lower()\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         gdkw["x"] = args["GRID"]["X"]\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         gdkw["y"] = args["GRID"]["Y"]\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.plot_graph.setXRange(*args["RANGE"]["X"])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.plot_graph.setYRange(*args["RANGE"]["Y"])\r\n      except KeyError:\r\n         pass\r\n      self.qtwdict[data[0]].showGrid(**gdkw)\r\n      pen = pyqtgraph.mkPen(**pnkw)\r\n      self.qtwdict[data[0]].plot(xpoints, ypoints, pen=pen, **plkw)PK\x03\x04\x14\x00\x00\x00\x00\x008}\x07YGg\xbb\x03\x9b\x01\x00\x00\x9b\x01\x00\x00\x1e\x00\x00\x00ipic/ns/builtins/QT5/thread.py"""A threading helper to implement the thread.start command in the Picturesque qt5 namespace."""\r\nimport PyQt5.QtCore, ipic.lang\r\n\r\nclass Worker(PyQt5.QtCore.QRunnable):\r\n    """A QRunnable modified to run Picturesque code."""\r\n    def __init__(self, code):\r\n        super(Worker, self).__init__()\r\n        self.code = code\r\n\r\n    @PyQt5.QtCore.pyqtSlot()\r\n    def run(self):\r\n        ipic.lang.lexer(self.code)PK\x03\x04\x14\x00\x00\x00\x00\x00\x01\x94\x1bY\nG\x0b\xf6\t\x03\x00\x00\t\x03\x00\x00\x1f\x00\x00\x00ipic/ns/builtins/QT5/wrapper.pyimport PyQt5.QtGui, ipic.lang, PyQt5.QtWidgets, ipic.path\r\n\r\nclass Action(PyQt5.QtWidgets.QAction):\r\n   def __init__(self, json, parent=None):\r\n      if parent is not None:\r\n         super().__init__(json["TEXT"], parent)\r\n      else:\r\n         super().__init__(json["TEXT"])\r\n      self.triggered.connect(lambda _: ipic.lang.lexer(ipic.lang.sub(json["ACTION"])))\r\n\r\nclass Icon(PyQt5.QtGui.QIcon):\r\n   def __init__(self, path):\r\n      super().__init__(ipic.path.path_insensitive(path))\r\n\r\nclass ContextMenu(PyQt5.QtWidgets.QMenu):\r\n   def __init__(self, actions, parent=None):\r\n      super().__init__()\r\n      for action in actions:\r\n         if parent is not None:\r\n            self.addAction(Action(action, parent))\r\n         else:\r\n            self.addAction(Action(action))PK\x03\x04\x14\x00\x00\x00\x00\x00\x93\x86\x1dY\xdb\xaecC\x9e9\x00\x00\x9e9\x00\x00 \x00\x00\x00ipic/ns/builtins/QT5/__init__.py"""The Picturesque qt5 namespace."""\r\nimport ipic.ns, PyQt5.QtWidgets, sys, shlex, json, ipic.lang, PyQt5.QtCore, ipic.path, PyQt5.QtGui, ipic.type, PyQt5.uic, PyQt5.QtQml\r\nfrom . import thread, wrapper\r\n__author__ = "Ridwan bin Mohammad (Tiash)"\r\n\r\nclass main(ipic.ns.CmdNamespace):\r\n   """The namespace class"""\r\n   def on_ns_init(self):\r\n      self.qtwdict = {}\r\n      self.app = None\r\n      self.threadpool = PyQt5.QtCore.QThreadPool()\r\n      self.sys_var["version"] = (PyQt5.QtCore.QT_VERSION_STR, {})\r\n      self.tab_dir = {\r\n         "NORTH": PyQt5.QtWidgets.QTabWidget.North,\r\n         "SOUTH": PyQt5.QtWidgets.QTabWidget.South,\r\n         "EAST": PyQt5.QtWidgets.QTabWidget.East,\r\n         "WEST": PyQt5.QtWidgets.QTabWidget.West\r\n      }\r\n   def do_qtCHAR0__initapp(self, val, csval):\r\n      self.app = PyQt5.QtWidgets.QApplication(sys.argv)\r\n   def do_initguiapp(self, val, csval):\r\n      self.app = PyQt5.QtGui.QGuiApplication(sys.argv)\r\n   def do_quitonlastwinclose(self, val, csval):\r\n      self.app.setQuitOnLastWindowClosed(ipic.type.pbool(val))\r\n   def do_quit(self, val, csval):\r\n      self.app.quit()\r\n   def do_qtCHAR0__wininit(self, val, csval):\r\n      self.qtwdict[val] = PyQt5.QtWidgets.QMainWindow()\r\n      self.var_dict[val] = f"<Qt5 window {val!r}>"\r\n      self.proc_dict[f"{val}.setfixedsize".upper()] = (\r\n        range(2), (lambda w, h:\r\n           self.qtwdict[val].setFixedSize(PyQt5.QtCore.QSize(int(w), int(h)))\r\n        ),\r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n      self.proc_dict[f"{val}.setcentralwidget".upper()] = (\r\n        (0,), (lambda container:\r\n           self.qtwdict[val].setCentralWidget(self.qtwdict[container])\r\n        ),\r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n      self.proc_dict[f"{val}.setminsize".upper()] = (\r\n        (0,), (lambda minsize:\r\n           self.qtwdict[val].setMinimumSize(int(minsize))\r\n        ),\r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n      self.proc_dict[f"{val}.setmaxsize".upper()] = (\r\n        (0,), (lambda minsize:\r\n           self.qtwdict[val].setMaximumSize(int(maxsize))\r\n        ),\r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n      self.proc_dict[f"{val}.setcentralwidget".upper()] = (\r\n        (0,), (lambda container:\r\n           self.qtwdict[val].setCentralWidget(self.qtwdict[container])\r\n        ),\r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n      self.proc_dict[f"{val}.show".upper()] = (\r\n        (), (lambda:\r\n           self.qtwdict[val].show()\r\n        ),\r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n   def do_winfromuifile(self, val, csval):\r\n      args = shlex.split(val)\r\n      self.qtwdict[args[0]] = PyQt5.uic.loadUi(ipic.path.path_insensitive(args[1]))\r\n      self.var_dict[args[0]] = f"<Qt5 window {args[0]!r} generated from {ipic.path.path_insensitive(args[1])!r}>"\r\n      self.proc_dict[f"{val}.show".upper()] = (\r\n        (), (lambda:\r\n           self.qtwdict[args[0]].show()\r\n        ),\r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n   \r\n   def do_winfromqmlfile(self, val, csval):\r\n      args = shlex.split(val)\r\n      args2 = shlex.split(csval)\r\n      self.qtwdict[args[0]] = PyQt5.QtQml.QQmlApplicationEngine()\r\n      self.qtwdict[args[0]].quit.connect(self.app.quit)\r\n      self.qtwdict[args[0]].load(args2[1])\r\n      self.var_dict[args[0]] = f"<Qt5 QtQuick window {args[0]!r} generated from {ipic.path.path_insensitive(args[1])!r}>"\r\n   def do_qtCHAR0__wintitle(self, val, csval):\r\n      args = shlex.split(val)\r\n      self.qtwdict[args[0]].setWindowTitle(args[1])\r\n   def do_qtCHAR0__btn(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QPushButton(args["TEXT"])\r\n      self.qtwdict[args["NAME"]].clicked.connect(lambda: ipic.lang.lexer(ipic.lang.sub(args["ONCLICK"])))\r\n      self.var_dict[args["NAME"]] = f"<Qt5 button {args[\'NAME\']!r}>"\r\n      self.proc_dict[f"{args[\'NAME\']}.set_enabled".upper()] = (\r\n        (0,), (lambda x: \r\n           self.qtwdict[args["NAME"]].setEnabled(ipic.type.pbool(x))\r\n        ), \r\n        ipic.lang.PROC_TYPE_PY\r\n      )\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_cmenu(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["PARENT"]].setContextMenuPolicy(PyQt5.QtCore.Qt.CustomContextMenu)\r\n      def cmenu(pos):\r\n         context = wrapper.ContextMenu(args["ACTIONS"], self.qtwdict[args["PARENT"]])\r\n         context.exec(self.qtwdict[args["PARENT"]].mapToGlobal(pos))\r\n      self.qtwdict[args["PARENT"]].customContextMenuRequested.connect(cmenu)\r\n   # def do_systrayicon(self, val, csval):\r\n      # args = json.loads(val)\r\n      # self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QSystemTrayIcon()\r\n      # self.qtwdict[args["NAME"]].setIcon(wrapper.Icon(args["ICON"]))\r\n      # self.qtwdict[args["NAME"]].setVisible(True)\r\n      # self.qtwdict[args["NAME"]].setContextMenu(wrapper.ContextMenu(args["MENU"])) \r\n   def do_chkbox(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QCheckBox()\r\n      self.var_dict[args["NAME"]] = f"<Qt5 checkbox {args[\'NAME\']!r}>"\r\n      self.var_dict[f"{args[\'NAME\']}.checked".upper()] = "$false"\r\n      def on_check(s):\r\n         self.var_dict[f"{args[\'NAME\']}.checked".upper()] = ipic.type.boolean(s == PyQt5.QtCore.Qt.Checked)\r\n      self.qtwdict[args["NAME"]].stateChanged.connect(on_check)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_qtCHAR0__entry(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QLineEdit()\r\n      self.var_dict[args["NAME"]] = f"<Qt5 entry {args[\'NAME\']!r}>"\r\n      self.var_dict[f"{args[\'NAME\']}.text".upper()] = ""\r\n      try:\r\n         self.qtwdict[args["NAME"]].setMaxLength(args["MAXLEN"])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.qtwdict[args["NAME"]].setPlaceholderText(args["PLACEHOLDER"])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.qtwdict[args["NAME"]].setReadOnly(args["READONLY"])\r\n      except KeyError:\r\n         pass\r\n      def on_text_changed(s):\r\n         self.var_dict[f"{args[\'NAME\']}.text".upper()] = s\r\n      self.qtwdict[args["NAME"]].textChanged.connect(on_text_changed)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_combobox(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QComboBox()\r\n      self.qtwdict[args["NAME"]].addItems(args["OPTS"])\r\n      self.var_dict[args["NAME"]] = f"<Qt5 combobox {args[\'NAME\']!r}>"\r\n      self.var_dict[f"{args[\'NAME\']}.selected".upper()] = self.qtwdict[args["NAME"]].currentText()\r\n      def on_change_text(s):\r\n         self.var_dict[f"{args[\'NAME\']}.selected".upper()] = s\r\n      self.qtwdict[args["NAME"]].currentTextChanged.connect(on_change_text)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_fontcombobox(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QFontComboBox()\r\n      self.var_dict[args["NAME"]] = f"<Qt5 font combobox {args[\'NAME\']!r}>"\r\n      self.var_dict[f"{args[\'NAME\']}.selected".upper()] = self.qtwdict[args["NAME"]].currentText()\r\n      def on_change_text(s):\r\n         self.var_dict[f"{args[\'NAME\']}.selected".upper()] = s\r\n      self.qtwdict[args["NAME"]].currentTextChanged.connect(on_change_text)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_spinbox(self, val, csval):\r\n      args = json.loads(val)\r\n      self.var_dict[args["NAME"]] = f"<Qt5 spinbox {args[\'NAME\']!r}>"\r\n      try:\r\n         self.qtwdict[args["NAME"]].setRange(*args["RANGE"])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.qtwdict[args["NAME"]].setPrefix(args["PREFIX"])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.qtwdict[args["NAME"]].setSuffix(args["SUFFIX"])\r\n      except KeyError:\r\n         pass\r\n      self.var_dict[f"{args[\'NAME\']}.val".upper()] = "0"\r\n      def on_change_text(s):\r\n         self.var_dict[f"{args[\'NAME\']}.val".upper()] = s\r\n      self.qtwdict[args["NAME"]].textChanged.connect(on_change_text)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_dblspinbox(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QDoubleSpinBox()\r\n      self.var_dict[args["NAME"]] = f"<Qt5 double spinbox {args[\'NAME\']!r}>"\r\n      try:\r\n         self.qtwdict[args["NAME"]].setRange(*args["RANGE"])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.qtwdict[args["NAME"]].setPrefix(args["PREFIX"])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.qtwdict[args["NAME"]].setSuffix(args["SUFFIX"])\r\n      except KeyError:\r\n         pass\r\n      self.var_dict[f"{args[\'NAME\']}.val".upper()] = "0"\r\n      def on_change_text(s):\r\n         self.var_dict[f"{args[\'NAME\']}.val".upper()] = s\r\n      self.qtwdict[args["NAME"]].textChanged.connect(on_change_text)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_slider(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QSlider()\r\n      self.var_dict[args["NAME"]] = f"<Qt5 slider {args[\'NAME\']!r}>"\r\n      try:\r\n         self.qtwdict[args["NAME"]].setRange(*args["RANGE"])\r\n      except KeyError:\r\n         pass\r\n      self.var_dict[f"{args[\'NAME\']}.val".upper()] = "0"\r\n      def on_value_changed(s):\r\n         self.var_dict[f"{args[\'NAME\']}.val".upper()] = str(s)\r\n      self.qtwdict[args["NAME"]].valueChanged.connect(on_value_changed)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_dial(self, val, csval):\r\n      args = json.loads(val)\r\n      self.var_dict[args["NAME"]] = f"<Qt5 dial {args[\'NAME\']!r}>"\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QDial()\r\n      try:\r\n         self.qtwdict[args["NAME"]].setRange(*args["RANGE"])\r\n      except KeyError:\r\n         pass\r\n      self.var_dict[f"{args[\'NAME\']}.val".upper()] = "0"\r\n      def on_value_changed(s):\r\n         self.var_dict[f"{args[\'NAME\']}.val".upper()] = str(s)\r\n      self.qtwdict[args["NAME"]].valueChanged.connect(on_value_changed)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_lswidget(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QListWidget()\r\n      self.qtwdict[args["NAME"]].addItems(args["OPTS"])\r\n      self.var_dict[args["NAME"]] = f"<Qt5 list widget {args[\'NAME\']!r}>"\r\n      self.var_dict[f"{args[\'NAME\']}.selected".upper()] = args["OPTS"][0]\r\n      def on_change_text(s):\r\n         self.var_dict[f"{args[\'NAME\']}.selected".upper()] = s\r\n      self.qtwdict[args["NAME"]].currentTextChanged.connect(on_change_text)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_qtCHAR0__lbl(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QLabel(args["TEXT"])\r\n      self.var_dict[args["NAME"]] = f"<Qt5 label {args[\'NAME\']!r}>"\r\n      self.proc_dict[f"{args[\'NAME\']}.set_text".upper()] = (("text",), self.qtwdict[args["NAME"]].setText, ipic.lang.PROC_TYPE_PY)\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_qtCHAR0__img(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QLabel()\r\n      self.qtwdict[args["NAME"]].setPixmap(PyQt5.QtGui.QPixmap(ipic.path.path_insensitive(args["IMAGE"])))\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)\r\n   def do_vlayout(self, val, csval):\r\n      args = shlex.split(val)\r\n      self.qtwdict[args[1]] = PyQt5.QtWidgets.QVBoxLayout()\r\n      container = self.qtwdict[args[0]]\r\n      container.setLayout(self.qtwdict[args[1]])\r\n   def do_hlayout(self, val, csval):\r\n      args = shlex.split(val)\r\n      self.qtwdict[args[1]] = PyQt5.QtWidgets.QHBoxLayout()\r\n      container = self.qtwdict[args[0]]\r\n      container.setLayout(self.qtwdict[args[1]])\r\n   def do_addvlayout(self, val, csval):\r\n      args = shlex.split(val)\r\n      self.qtwdict[args[1]] = PyQt5.QtWidgets.QVBoxLayout()\r\n      self.qtwdict[args[0]].addLayout(self.qtwdict[args[1]])\r\n   def do_addhlayout(self, val, csval):\r\n      args = shlex.split(val)\r\n      self.qtwdict[args[1]] = PyQt5.QtWidgets.QHBoxLayout()\r\n      self.qtwdict[args[0]].addLayout(self.qtwdict[args[1]])\r\n   def do_appexec(self, val, csval):\r\n      sys.exit(self.app.exec())\r\n   def do_threadCHAR0__start(self, val, csval):\r\n      worker = thread.Worker(ipic.lang.sub(csval))\r\n      self.threadpool.start(worker)\r\n   def do_qtCHAR0__frm(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QWidget()\r\n      self.var_dict[args["NAME"]] = f"<Qt5 frame {args[\'NAME\']!r}>"\r\n      try:\r\n         args["ADD"]\r\n      except KeyError:\r\n         args["ADD"] = True\r\n      if args["ADD"]:\r\n         try:\r\n            self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n         except BaseException as err:\r\n            self.out.error(err)\r\n   def do_tabs(self, val, csval):\r\n      args = json.loads(val)\r\n      self.qtwdict[args["NAME"]] = PyQt5.QtWidgets.QTabWidget()\r\n      try:\r\n         self.qtwdict[args["NAME"]].setTabPosition(self.tab_dir[args["TAB_POS"]])\r\n      except KeyError:\r\n         pass\r\n      try:\r\n         self.qtwdict[args["NAME"]].setMovable(args["MOVABLE"])\r\n      except KeyError:\r\n         pass\r\n      for x in args["TABS"]:\r\n         self.qtwdict[args["NAME"]].addTab(self.qtwdict[x["WIDGET"]], x["NAME"])\r\n      try:\r\n         self.qtwdict[args["LAYOUT"]].addWidget(self.qtwdict[args["NAME"]])\r\n      except BaseException as err:\r\n         self.out.error(err)PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x8c\x92\x1aY\xf1\xcfVNR\x03\x00\x00R\x03\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\x00\x00\x00\x00ipic/errors.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xba\x93\x1aY\x00\xa2\xbd\x98\xb3\x9f\x00\x00\xb3\x9f\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81~\x03\x00\x00ipic/lang.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00b\x88\xfeXJK\xb1\xfa\xb7\x06\x00\x00\xb7\x06\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81[\xa3\x00\x00ipic/out.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00vu\xe5Xe\xf3\x02\xd4n\x05\x00\x00n\x05\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81;\xaa\x00\x00ipic/path.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x04\xb0\xf1X\x11\xcc_\xbf \x02\x00\x00 \x02\x00\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\xd3\xaf\x00\x00ipic/setup.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb0\x8e\x01Y\xf5~lDH\x00\x00\x00H\x00\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\x1e\xb2\x00\x00ipic/string.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00,\x8c\x1aYO\xeb\xf4\xa1\x02\x04\x00\x00\x02\x04\x00\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\x92\xb2\x00\x00ipic/table.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x004\x02\x16YvA\xdc\xf8\xea\x04\x00\x00\xea\x04\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\xbf\xb6\x00\x00ipic/type.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00;z\x07Y\xdd\x04\xa4\x17:\x00\x00\x00:\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\xd3\xbb\x00\x00ipic/warnings.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00g\x94\x1aYM;\x12\t\t\x16\x00\x00\t\x16\x00\x00\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81;\xbc\x00\x00ipic/ns/__init__.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xf5\x8e\x08YZ#\x9a\xec~\x00\x00\x00~\x00\x00\x00\x1e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81u\xd2\x00\x00ipic/ns/builtins/HELLOWORLD.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb4r\x1aYJ\xddn\xf3\x9b\t\x00\x00\x9b\t\x00\x00\x1d\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81/\xd3\x00\x00ipic/ns/builtins/QT5/GRAPH.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x008}\x07YGg\xbb\x03\x9b\x01\x00\x00\x9b\x01\x00\x00\x1e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\x05\xdd\x00\x00ipic/ns/builtins/QT5/thread.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x01\x94\x1bY\nG\x0b\xf6\t\x03\x00\x00\t\x03\x00\x00\x1f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81\xdc\xde\x00\x00ipic/ns/builtins/QT5/wrapper.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93\x86\x1dY\xdb\xaecC\x9e9\x00\x00\x9e9\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x81"\xe2\x00\x00ipic/ns/builtins/QT5/__init__.pyPK\x05\x06\x00\x00\x00\x00\x0f\x00\x0f\x00\xd2\x03\x00\x00\xfe\x1b\x01\x00\x00\x00')
f.close()
log.info("Extracting the zipped Picturesque interpreter...")
zipfile.ZipFile(f"{code}.zip").extractall("ipic")
log.info("Running PyInstaller.")
pyi_args = []
if platform.system() == "Windows" or platform.system() == "Darwin":
    if args.windowed:
         pyi_args.append("-w")
PyInstaller.__main__.run(["-F", f"{args.filename}.{code}.py", *pyi_args, "-p", "./ipic", "-n", args.filename])
log.info("Cleaning up...")
os.unlink(f"{code}.zip")
os.unlink(f"{args.filename}.{code}.py")
os.unlink(f"{args.filename}.spec")
shutil.rmtree("ipic")
log.info("Done!")